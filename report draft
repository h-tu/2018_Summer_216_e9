Below are tables of average wall time (in seconds) for various combinations of 
thread count and element count (100 trials per combination) on both tasks:

*****
*Max*
*****

 Elements   |    10^2    |    10^3    |    10^4    |    10^5    |    10^6    |    10^7    |    10^8    |    10^9    |
  Threads
    01      | 00.000071  | 00.000049  | 00.000078  | 00.000384  | 00.003029  | 00.028343  | 00.281002  | 02.825021  |
------------------------------------------------------------------------------------------------------------------------
    02      | 00.281002  | 00.000086  | 00.000104  | 00.000282  | 00.001713  | 00.015342  | 00.161376  | 01.611672  |
------------------------------------------------------------------------------------------------------------------------
    03      | 00.161376  | 00.000128  | 00.000131  | 00.000287  | 00.001399  | 00.012563  | 00.119444  | 01.177393  |
------------------------------------------------------------------------------------------------------------------------
    04      | 00.119444  | 00.000206  | 00.000200  | 00.000256  | 00.001172  | 00.009834  | 00.100140  | 01.122149  |
------------------------------------------------------------------------------------------------------------------------
    05      | 00.100140  | 00.000341  | 00.000329  | 00.000471  | 00.001481  | 00.013630  | 00.110274  | 01.182636  |
------------------------------------------------------------------------------------------------------------------------
    06      | 00.110274  | 00.000417  | 00.000444  | 00.000461  | 00.001389  | 00.012041  | 00.101183  | 01.170853  |
------------------------------------------------------------------------------------------------------------------------
    07      | 00.101183  | 00.000523  | 00.000557  | 00.000581  | 00.001357  | 00.011171  | 00.104121  | 01.165144  |
------------------------------------------------------------------------------------------------------------------------
    08      | 00.104121  | 00.000627  | 00.000638  | 00.000625  | 00.001456  | 00.010286  | 00.104558  | 01.165390  |
------------------------------------------------------------------------------------------------------------------------
    09      | 00.104558  | 00.000745  | 00.000749  | 00.000729  | 00.001479  | 00.011985  | 00.115117  | 01.172760  |
------------------------------------------------------------------------------------------------------------------------
    10      | 00.115117  | 00.000841  | 00.000843  | 00.000823  | 00.001516  | 00.011157  | 00.108381  | 01.164909  |
------------------------------------------------------------------------------------------------------------------------

(insert Sum table here)

For small amounts of data, there is a large overhead associated with having multiple threads running synchronously.
Here a single threaded execution is fast and efficient as compared to having multiple threads.
However, as the number of elements in the array is increased, it can be observed that the multithreaded execution is 
more efficient due to its parallel nature of computation. On the other hand, if the data is kept constant and if the 
number of threads is increased, then the time taken plateaus out. This happens because the benefit of having an extra 
thread for computation keeps decaying. With the increasing number of threads and the data being constant, each thread 
has less data for computation and again the overhead of having threads makes the program execution slow.

With these particular tasks, since the program is never waiting for I/O, the wall time plateaus when the number of threads
is equal to the number of cores available for parallel execution (in this case, 4). However, if this task did involve waiting
for I/O (e.g. a web crawler or a program that indexed files on a hard drive), the plateau would likely occur at a much higher
thread count, and load balancing would become more important.
